//! This module contains the core algorithm for generating a mesh from a voxel
//! storage chunk.

use bevy::prelude::*;
use bones3_core::prelude::*;

use crate::mesh::block_model::{BlockOcclusion, BlockShape};
use crate::prelude::{ChunkMaterialList, ChunkMesh};
use crate::vertex_data::ShapeBuilder;

/// Builds a temp mesh for a virtual 16x16x16 chunk with support for reading
/// block data from neighboring virtual chunks.
///
/// This method will iterator over all values within the 16x16x16 local
/// coordinates and read the corresponding block values from the `get_block`
/// parameter function provided. For neighboring chunks, values one block
/// outside of the standard local block coordinates in each of the six cubic
/// directions are also read using the `get_block` parameter function with
/// values that would lie outside of a standard chunk block coordinate.
pub fn build_chunk_mesh<T, G>(get_block: G, material_list: &ChunkMaterialList) -> ShapeBuilder<'_>
where
    T: BlockData + BlockShape,
    G: Fn(IVec3) -> T,
{
    let mut shape_builder = ShapeBuilder::new(material_list);

    for block_pos in Region::CHUNK.iter() {
        let data = get_block(block_pos);

        let check_occlusion = |occlusion: &mut BlockOcclusion, face: BlockOcclusion| {
            if get_block(block_pos + face.into_offset())
                .get_occludes()
                .contains(face.opposite_face())
            {
                occlusion.insert(face);
            }
        };

        let mut occlusion = BlockOcclusion::empty();
        check_occlusion(&mut occlusion, BlockOcclusion::NEG_X);
        check_occlusion(&mut occlusion, BlockOcclusion::POS_X);
        check_occlusion(&mut occlusion, BlockOcclusion::NEG_Y);
        check_occlusion(&mut occlusion, BlockOcclusion::POS_Y);
        check_occlusion(&mut occlusion, BlockOcclusion::NEG_Z);
        check_occlusion(&mut occlusion, BlockOcclusion::POS_Z);

        shape_builder.set_local_pos(block_pos);
        shape_builder.set_occlusion(occlusion);
        data.write_shape(&mut shape_builder);
    }

    shape_builder
}

/// This function will update the provided chunk to use the chunk meshes
/// generated by the shape builder instance for chunk model rendering.
pub fn apply_shape_builder(
    chunk_id: Entity,
    shape_builder: ShapeBuilder,
    mesh_query: &Query<(Entity, &Parent), With<ChunkMesh>>,
    meshes: &mut ResMut<Assets<Mesh>>,
    commands: &mut Commands,
) {
    for (chunk_mesh_id, parent) in mesh_query.iter() {
        if parent.get() == chunk_id {
            commands.entity(chunk_mesh_id).despawn();
        }
    }

    for (mesh, material_handle) in shape_builder.into_meshes() {
        let mesh_handle = meshes.add(mesh);

        commands
            .spawn((
                PbrBundle {
                    mesh: mesh_handle,
                    material: material_handle,
                    ..default()
                },
                ChunkMesh,
            ))
            .set_parent(chunk_id);
    }
}
